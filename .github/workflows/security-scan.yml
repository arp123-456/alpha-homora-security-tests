name: LP Oracle Security Scanner - Cloud Tests

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    # Run daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      protocol:
        description: 'Protocol to scan (all, uniswap-v2, curve, balancer)'
        required: false
        default: 'all'
      fuzz_runs:
        description: 'Number of fuzz runs'
        required: false
        default: '10000'

env:
  FOUNDRY_PROFILE: ci
  MAINNET_RPC_URL: ${{ secrets.MAINNET_RPC_URL }}
  ETHERSCAN_API_KEY: ${{ secrets.ETHERSCAN_API_KEY }}

jobs:
  setup:
    name: Setup and Verify
    runs-on: ubuntu-latest
    outputs:
      cache-key: ${{ steps.cache-keys.outputs.key }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Generate cache key
        id: cache-keys
        run: |
          echo "key=foundry-${{ hashFiles('foundry.toml') }}-${{ hashFiles('lib/**') }}" >> $GITHUB_OUTPUT

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1
        with:
          version: nightly

      - name: Verify Foundry installation
        run: |
          forge --version
          cast --version
          anvil --version

      - name: Cache Foundry dependencies
        uses: actions/cache@v3
        with:
          path: |
            ~/.foundry
            lib
            cache
            out
          key: ${{ steps.cache-keys.outputs.key }}
          restore-keys: |
            foundry-${{ hashFiles('foundry.toml') }}-

  foundry-tests:
    name: Foundry Tests
    runs-on: ubuntu-latest
    needs: setup
    strategy:
      matrix:
        test-suite:
          - OracleManipulation
          - RealisticFlashLoan
          - UniswapV2Oracle
          - CurveOracle
          - BalancerOracle
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Restore cache
        uses: actions/cache@v3
        with:
          path: |
            ~/.foundry
            lib
            cache
            out
          key: ${{ needs.setup.outputs.cache-key }}

      - name: Install dependencies
        run: forge install

      - name: Build contracts
        run: forge build --sizes

      - name: Run ${{ matrix.test-suite }} tests
        run: |
          forge test --match-contract ${{ matrix.test-suite }} -vvv --gas-report
        continue-on-error: true

      - name: Generate test report
        if: always()
        run: |
          mkdir -p reports
          forge test --match-contract ${{ matrix.test-suite }} --json > reports/${{ matrix.test-suite }}.json

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: foundry-test-results
          path: reports/${{ matrix.test-suite }}.json

  slither-analysis:
    name: Slither Static Analysis
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Slither
        run: |
          pip3 install slither-analyzer
          pip3 install solc-select
          solc-select install 0.8.20
          solc-select use 0.8.20

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Restore cache
        uses: actions/cache@v3
        with:
          path: |
            ~/.foundry
            lib
            cache
            out
          key: ${{ needs.setup.outputs.cache-key }}

      - name: Install dependencies
        run: forge install

      - name: Run Slither
        run: |
          mkdir -p reports
          slither . --config-file slither.config.json --json reports/slither.json || true
          slither . --config-file slither.config.json --print human-summary > reports/slither-summary.txt || true

      - name: Check for critical vulnerabilities
        run: |
          if grep -q "HIGH" reports/slither-summary.txt; then
            echo "::warning::High severity vulnerabilities found"
          fi
          if grep -q "CRITICAL" reports/slither-summary.txt; then
            echo "::error::Critical vulnerabilities found"
            exit 1
          fi
        continue-on-error: true

      - name: Upload Slither results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: slither-results
          path: reports/slither*

  echidna-fuzzing:
    name: Echidna Fuzzing
    runs-on: ubuntu-latest
    needs: setup
    strategy:
      matrix:
        contract:
          - LPOracle
          - UniswapV2Oracle
          - CurveOracle
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Echidna
        run: |
          wget https://github.com/crytic/echidna/releases/download/v2.2.1/echidna-2.2.1-Linux.tar.gz
          tar -xzf echidna-2.2.1-Linux.tar.gz
          sudo mv echidna /usr/local/bin/
          echidna-test --version

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Restore cache
        uses: actions/cache@v3
        with:
          path: |
            ~/.foundry
            lib
            cache
            out
          key: ${{ needs.setup.outputs.cache-key }}

      - name: Install dependencies
        run: forge install

      - name: Run Echidna fuzzing
        run: |
          mkdir -p reports corpus
          echidna-test . --contract ${{ matrix.contract }} --config echidna.yaml > reports/echidna-${{ matrix.contract }}.txt || true
        continue-on-error: true

      - name: Upload Echidna results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: echidna-results
          path: |
            reports/echidna-*.txt
            corpus/

  mythril-analysis:
    name: Mythril Symbolic Execution
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Mythril
        run: |
          pip3 install mythril
          myth version

      - name: Run Mythril analysis
        run: |
          mkdir -p reports
          for contract in src/*.sol; do
            filename=$(basename "$contract" .sol)
            myth analyze "$contract" -o json > "reports/mythril-$filename.json" || true
          done
        continue-on-error: true

      - name: Upload Mythril results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: mythril-results
          path: reports/mythril-*.json

  coverage:
    name: Test Coverage
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Restore cache
        uses: actions/cache@v3
        with:
          path: |
            ~/.foundry
            lib
            cache
            out
          key: ${{ needs.setup.outputs.cache-key }}

      - name: Install dependencies
        run: forge install

      - name: Generate coverage report
        run: |
          forge coverage --report lcov
          forge coverage --report summary > coverage-summary.txt

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./lcov.info
          flags: foundry
          name: foundry-coverage

      - name: Upload coverage results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: coverage-results
          path: |
            lcov.info
            coverage-summary.txt

  gas-report:
    name: Gas Usage Report
    runs-on: ubuntu-latest
    needs: setup
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Restore cache
        uses: actions/cache@v3
        with:
          path: |
            ~/.foundry
            lib
            cache
            out
          key: ${{ needs.setup.outputs.cache-key }}

      - name: Install dependencies
        run: forge install

      - name: Generate gas report
        run: |
          forge test --gas-report > gas-report.txt

      - name: Upload gas report
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: gas-report
          path: gas-report.txt

  protocol-scans:
    name: Protocol Security Scans
    runs-on: ubuntu-latest
    needs: setup
    strategy:
      matrix:
        protocol:
          - uniswap-v2
          - curve
          - balancer
          - sushiswap
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive

      - name: Install Foundry
        uses: foundry-rs/foundry-toolchain@v1

      - name: Restore cache
        uses: actions/cache@v3
        with:
          path: |
            ~/.foundry
            lib
            cache
            out
          key: ${{ needs.setup.outputs.cache-key }}

      - name: Install dependencies
        run: forge install

      - name: Scan ${{ matrix.protocol }}
        run: |
          mkdir -p reports
          forge test --match-contract $(echo ${{ matrix.protocol }} | sed 's/-//g' | awk '{print toupper(substr($0,1,1)) tolower(substr($0,2))}')Oracle -vvv > reports/scan-${{ matrix.protocol }}.txt
        continue-on-error: true

      - name: Upload scan results
        if: always()
        uses: actions/upload-artifact@v3
        with:
          name: protocol-scan-results
          path: reports/scan-${{ matrix.protocol }}.txt

  generate-report:
    name: Generate Final Report
    runs-on: ubuntu-latest
    needs: [foundry-tests, slither-analysis, echidna-fuzzing, mythril-analysis, coverage, gas-report, protocol-scans]
    if: always()
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download all artifacts
        uses: actions/download-artifact@v3
        with:
          path: artifacts

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Generate comprehensive report
        run: |
          python3 << 'EOF'
          import json
          import os
          from datetime import datetime

          report = {
              "timestamp": datetime.now().isoformat(),
              "summary": {
                  "total_tests": 0,
                  "passed": 0,
                  "failed": 0,
                  "vulnerabilities": {
                      "critical": 0,
                      "high": 0,
                      "medium": 0,
                      "low": 0
                  }
              },
              "details": {}
          }

          # Process artifacts
          artifacts_dir = "artifacts"
          if os.path.exists(artifacts_dir):
              for root, dirs, files in os.walk(artifacts_dir):
                  for file in files:
                      if file.endswith('.json'):
                          filepath = os.path.join(root, file)
                          try:
                              with open(filepath, 'r') as f:
                                  data = json.load(f)
                                  report["details"][file] = data
                          except:
                              pass

          # Save report
          with open('final-report.json', 'w') as f:
              json.dump(report, f, indent=2)

          # Generate markdown summary
          with open('SECURITY_REPORT.md', 'w') as f:
              f.write(f"# Security Scan Report\n\n")
              f.write(f"**Generated:** {report['timestamp']}\n\n")
              f.write(f"## Summary\n\n")
              f.write(f"- Total Tests: {report['summary']['total_tests']}\n")
              f.write(f"- Passed: {report['summary']['passed']}\n")
              f.write(f"- Failed: {report['summary']['failed']}\n\n")
              f.write(f"## Vulnerabilities\n\n")
              f.write(f"- ðŸ”´ Critical: {report['summary']['vulnerabilities']['critical']}\n")
              f.write(f"- ðŸŸ  High: {report['summary']['vulnerabilities']['high']}\n")
              f.write(f"- ðŸŸ¡ Medium: {report['summary']['vulnerabilities']['medium']}\n")
              f.write(f"- ðŸŸ¢ Low: {report['summary']['vulnerabilities']['low']}\n")

          print("Report generated successfully")
          EOF

      - name: Upload final report
        uses: actions/upload-artifact@v3
        with:
          name: final-security-report
          path: |
            final-report.json
            SECURITY_REPORT.md

      - name: Comment PR with results
        if: github.event_name == 'pull_request'
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('SECURITY_REPORT.md', 'utf8');
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: report
            });

  notify:
    name: Send Notifications
    runs-on: ubuntu-latest
    needs: [generate-report]
    if: always()
    steps:
      - name: Send Slack notification
        if: env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          curl -X POST $SLACK_WEBHOOK_URL \
            -H 'Content-Type: application/json' \
            -d '{
              "text": "Security scan completed for ${{ github.repository }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Security Scan Results*\nRepository: ${{ github.repository }}\nBranch: ${{ github.ref }}\nStatus: ${{ job.status }}"
                  }
                }
              ]
            }'

      - name: Send email notification
        if: env.SENDGRID_API_KEY != ''
        env:
          SENDGRID_API_KEY: ${{ secrets.SENDGRID_API_KEY }}
        run: |
          echo "Email notification would be sent here"